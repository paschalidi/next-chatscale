{"version":3,"sources":["../src/index.ts","../src/context/ChatContext/index.tsx","../src/context/ChatContext/useChannels.ts","../src/lib/logError.ts","../src/config.ts","../src/lib/apiRequest.ts","../src/services/index.ts","../src/context/ChatContext/useWebsocket.ts","../src/context/ChatContext/useChannelMessage.ts","../src/components/ChannelList/index.tsx","../src/components/MessageInput/index.tsx","../src/components/Messages/index.tsx","../../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs"],"names":["import_react","data","React","e"],"mappings":"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","sourcesContent":["export { ChatProvider } from './context/ChatContext';\nexport { ChannelList } from './components/ChannelList';\nexport { MessageInput } from './components/MessageInput';\nexport { Messages } from './components/Messages';\n\nexport { useChat } from './context/ChatContext';\n\nexport type { ChatListProps } from './components/ChannelList/types';\nexport type { MessageInputProps } from './components/MessageInput/types';\nexport type { MessagesProps } from './components/Messages/types';\n\nexport type { ChannelResponseDto, ChannelsResponseDto, MessageResponseDto, MessagesResponseDto } from './types';","import * as React from 'react';\nimport { useMemo } from 'react';\nimport { useChannels } from \"./useChannels\";\nimport { useWebSocket } from \"./useWebsocket\";\nimport { useChannelMessages } from \"./useChannelMessage\";\nimport { config } from \"../../config\";\nimport { ChannelsResponseDto, CombinedMessagesDto } from \"../../types\";\n\ninterface Resource<T> {\n  data: T | undefined;\n  isLoading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n}\n\ninterface ChatContextType {\n  apiKey: string;\n  organizationId: string;\n  activeChannel: {\n    name: string;\n    id: string | undefined;\n  }\n  currentUser: {\n    id: string;\n    userName: string;\n    isConnected: boolean;\n  }\n  wsEndpoint: string;\n  ws: WebSocket | null;\n  messages: Resource<CombinedMessagesDto>;\n  channels: Resource<ChannelsResponseDto>;\n}\n\ninterface ChatProviderProps {\n  children: React.ReactNode;\n  apiKey: string;\n  appId: string;\n  channelName: string;\n  userId: string;\n  userName?: string;\n  options?: {\n    reconnectInterval?: number;\n    maxReconnectAttempts?: number;\n    debug?: boolean;\n  };\n}\n\n\nconst ChatContext = React.createContext<ChatContextType | null>(null);\n\nexport const ChatProvider: React.FC<ChatProviderProps> = ({\n                                                            children,\n                                                            apiKey: apiKey,\n                                                            appId: organizationId,\n                                                            channelName,\n                                                            userId,\n                                                            userName = 'Unknown user',\n                                                          }) => {\n  const { isConnected, messages: wsMessages, ws } = useWebSocket(channelName);\n  const {\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels,\n    currentChannelId\n  } = useChannels({ channelName, organizationId, apiKey });\n\n  const {\n    messages: channelMessages,\n    areMessagesLoading,\n    refetchMessages,\n    messagesError\n  } = useChannelMessages({\n    channelId: currentChannelId,\n    organizationId,\n    apiKey\n  });\n\n  const value = useMemo<ChatContextType>(() => ({\n    apiKey,\n    organizationId,\n    currentUser: {\n      id: userId,\n      userName: userName,\n      isConnected,\n\n    },\n    activeChannel: {\n      name: channelName,\n      id: currentChannelId\n    },\n    channels: {\n      data: channels,\n      isLoading: isChannelsLoading,\n      error: channelsError,\n      refetch: refetchChannels\n    },\n    messages: {\n      data: [...(channelMessages || []), ...(wsMessages || [])],\n      isLoading: areMessagesLoading,\n      error: messagesError,\n      refetch: refetchMessages\n    },\n    wsEndpoint: `${config.rust_ws_url}/chat/${channelName}`,\n    ws,\n  }), [\n    apiKey,\n    organizationId,\n    channelName,\n    currentChannelId,\n    isConnected,\n    channelMessages,\n    wsMessages,\n    areMessagesLoading,\n    messagesError,\n    refetchMessages,\n    ws,\n    userId,\n    userName,\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels\n  ]);\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};\n\nexport const useChat = () => {\n  const context = React.useContext(ChatContext);\n  if (!context) {\n    throw new Error('useChat must be used within a ChatProvider');\n  }\n  return context;\n};","import { useEffect, useState } from 'react';\nimport { fetchChannels } from \"../../services\";\nimport { ChannelsResponseDto } from \"../../types\";\n\ninterface UseChannelsReturn {\n  channels: ChannelsResponseDto | undefined;\n  currentChannelId: string | undefined;\n  isChannelsLoading: boolean;\n  channelsError: Error | null;\n  refetchChannels: () => Promise<void>;\n}\n\nexport const useChannels = ({ channelName, organizationId, apiKey }: {\n  channelName: string,\n  organizationId: string\n  apiKey: string\n}): UseChannelsReturn => {\n  const [data, setData] = useState<ChannelsResponseDto>();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchData = async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { data } = await fetchChannels({ organizationId, apiKey });\n      setData(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch channels'));\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return {\n    currentChannelId: data?.find(channel => channelName === channel.name)?.id,\n    channels: data,\n    isChannelsLoading: isLoading,\n    channelsError: error,\n    refetchChannels: fetchData\n  };\n};","interface ErrorLog {\n  message: string;\n  stack?: string;\n  timestamp: string;\n\n  [key: string]: any; // Additional dynamic properties\n}\n\nexport const logError = (\n  error: unknown,\n  additionalContext: Record<string, unknown> = {}\n): void => {\n  // Determine the error message and stack based on the error type\n  let message: string;\n  let stack: string | undefined;\n\n  if (error instanceof Error) {\n    message = error.message;\n    stack = error.stack;\n  } else {\n    message = String(error); // Convert error to string if it's not an instance of Error\n    stack = undefined;\n  }\n\n  const errorLog: ErrorLog = {\n    message,\n    stack,\n    timestamp: new Date().toISOString(),\n    ...additionalContext\n  };\n\n  // Sentry.captureException(error, {\n  //   extra: errorLog\n  // });\n\n  console.error(errorLog);\n};\n","export const config = {\n  rust_api_url: 'https://api.rechat.cloud',\n  rust_ws_url: 'wss://api.rechat.cloud/ws',\n};","import { logError } from './logError';\nimport { config } from \"../config\";\n\nexport async function apiRequest<T>(\n  path: string,\n  fetchOptions: RequestInit = {},\n  serverOptions: { serverUrl?: string; cache?: boolean } = {}\n): Promise<T> {\n  const defaultHeaders = {\n    'Content-Type': 'application/json',\n  };\n\n  const { serverUrl = config.rust_api_url, } = serverOptions;\n  const url = `${serverUrl}${path}`;\n\n  try {\n\n    const response = await fetch(url, {\n      ...fetchOptions,\n      headers: {\n        ...defaultHeaders,\n        ...fetchOptions.headers,\n      },\n    });\n\n    const contentType = response.headers.get('content-type');\n\n    if (!response.ok) {\n      // if the response is not ok, and is not a json but and html, eg 502 errors\n      if (!contentType || !contentType.includes('application/json')) {\n        throw new Error(\n          `${url} <- Error ${response.status}: Invalid content-type. Expected application/json, got ${JSON.stringify(response.body)}`\n        );\n      }\n\n      const errorData = await response.json();\n\n\n      throw new Error(\n        `${url} <- Error ${response.status}: ${JSON.stringify(\n          errorData,\n          null,\n          2\n        )} `\n      );\n    }\n\n    if (response.status === 204) {\n      return { status: '204' } as T;\n    }\n\n    return (await response.json()) as T;\n  } catch (error) {\n    if (error instanceof Error) {\n      logErrorMetadata(error, url);\n    } else {\n      logError(error, { context: 'Unexpected Error', url });\n    }\n    throw error;\n  }\n}\n\nconst logErrorMetadata = (error: Error, url: string) => {\n  if (error.name === 'AbortError') {\n    logError(`Timeout â€“ ${error.name} ${error}`, {\n      context: 'Timeout Error',\n      url\n    });\n  } else {\n    logError(`${error.name} ${error}`, { context: 'Fetch Error', url });\n  }\n};\n","import { apiRequest } from \"../lib/apiRequest\";\nimport { ChannelsResponseDto, MessageRequestDto, MessageResponseDto, MessagesResponseDto } from \"../types\";\n\n\nexport const fetchChannels = async ({ organizationId, apiKey }: { organizationId: string; apiKey: string }) => {\n  return await apiRequest<{ data: ChannelsResponseDto, message: string }>(\n    `/api/organizations/${organizationId}/channels`,\n    {\n      method: \"GET\",\n      headers: {\n        \"X-API-Key\": apiKey,\n        Accept: 'application/json',\n      }\n    }\n  );\n}\n\nexport const createNewChannel = async ({ name }: { name: string }) => {\n  return await apiRequest<{ data: ChannelsResponseDto, message: string }>(\n    '/api/channels',\n    {\n      method: \"POST\",\n      headers: {\n        Accept: 'application/json',\n      },\n      body: JSON.stringify({ name })\n    },\n  );\n}\n\nexport const postMessage = async ({ apiKey, organizationId, message }: {\n  organizationId: string;\n  apiKey: string;\n  message: MessageRequestDto\n}) => {\n  return await apiRequest<{ data: MessageResponseDto, message: string }>(\n    `/api/organizations/${organizationId}/messages`,\n    {\n      method: \"POST\",\n      headers: {\n        \"X-API-Key\": apiKey,\n      },\n      body: JSON.stringify(message)\n    },\n  );\n}\n\nexport const fetchMessagesByChannelId = async ({ channelId, organizationId, apiKey }: {\n  channelId: string;\n  organizationId: string;\n  apiKey: string\n}) => {\n  return await apiRequest<{ data: MessagesResponseDto, message: string }>(\n    `/api/organizations/${organizationId}/messages/${channelId}`,\n    {\n      method: \"GET\",\n      headers: {\n        \"X-API-Key\": apiKey,\n        Accept: 'application/json',\n      },\n    },\n  );\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { config } from \"../../config\";\nimport { MessageRequestDto } from \"../../types\";\n\nexport function useWebSocket(channelName: string) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState<MessageRequestDto[]>([]);\n  const ws = useRef<WebSocket | null>(null);\n\n\n  useEffect(() => {\n    const connect = () => {\n      // Only create a new connection if there isn't one already\n      console.log('Connecting to WebSocket the ', channelName);\n      ws.current = new WebSocket(`${config.rust_ws_url}/chat/${channelName}`);\n\n      ws.current.onopen = () => {\n        setIsConnected(true);\n        console.log('WebSocket connected');\n      };\n\n      ws.current.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        setMessages(prev => [...prev, {\n          participant_id: data.participant_id,\n          channel_name: data.channel_name,\n          content: data.content,\n        }]);\n      };\n\n      ws.current.onclose = () => {\n        setIsConnected(false);\n        console.log('WebSocket closed');\n      };\n    };\n\n    connect();\n\n    // Cleanup function\n    return () => {\n      // Only close if connection exists and is open\n      if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n        ws.current.close();\n      }\n    };\n  }, [channelName]);\n\n  return { isConnected, messages, ws: ws.current };\n}","import { useCallback, useEffect, useState } from 'react';\n\nimport { MessagesResponseDto } from \"../../types\";\nimport { fetchMessagesByChannelId } from \"../../services\";\n\nexport function useChannelMessages({\n                                     channelId, organizationId, apiKey\n                                   }: {\n  channelId?: string; organizationId: string; apiKey: string\n}) {\n  const [messages, setMessages] = useState<MessagesResponseDto>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchMessages = useCallback(async () => {\n    if (!channelId) return;\n\n    setIsLoading(true);\n    try {\n      const { data } = await fetchMessagesByChannelId({ channelId, organizationId, apiKey });\n      setMessages(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch messages'));\n    } finally {\n      setIsLoading(false);\n    }\n  }, [channelId]);\n\n  useEffect(() => {\n    fetchMessages();\n  }, [channelId, fetchMessages]);\n\n  return { messages, areMessagesLoading: isLoading, messagesError: error, refetchMessages: fetchMessages };\n}","'use client'\nimport * as React from 'react';\nimport { ChatListProps } from './types';\nimport { useChat } from \"../../context/ChatContext\";\n\nexport const ChannelList: React.FC<ChatListProps> = ({\n                                                    limit = 50,\n                                                    onChatSelect,\n                                                    customStyles = {},\n                                                    renderItem\n                                                  }) => {\n  const { channels } = useChat();\n\n  if (channels.isLoading) {\n    return <div>Loading chats...</div>;\n  }\n\n  return (\n    <div className={customStyles.container}>\n      {channels.data?.map((channel) => (\n        <div\n          key={channel.id}\n          onClick={() => onChatSelect?.(channel)}\n          className={customStyles.chatItem}\n        >\n          {renderItem ? (\n            renderItem(channel)\n          ) : (\n            <div>\n              <h3>{channel.name}</h3>\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n};","import * as React from 'react';\nimport { MessageInputProps } from './types';\nimport { useChat } from '../../context/ChatContext';\nimport { postMessage } from \"../../services\";\nimport { MessageRequestDto } from \"../../types\";\n\nexport const MessageInput: React.FC<MessageInputProps> = ({\n                                                            placeholder = 'Type a message...',\n                                                            onSend,\n                                                            maxLength = 1000,\n                                                            disabled = false,\n\n                                                          }) => {\n  const { apiKey, organizationId } = useChat()\n  const [message, setMessage] = React.useState('');\n  const {\n    ws,\n    currentUser: {\n      id: currentUserId,\n      isConnected\n    },\n    activeChannel: {\n      name: channelName\n    },\n  } = useChat();\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (message.trim() && ws && isConnected) {\n      const data = {\n        channel_name: channelName,\n        participant_id: currentUserId,\n        content: message,\n      } as MessageRequestDto\n\n      ws.send(JSON.stringify(data));\n\n      onSend?.(message);\n      setMessage('');\n\n      try {\n        await postMessage({\n          apiKey,\n          organizationId,\n          message: data\n        });\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"flex gap-2\">\n      <input\n        type=\"text\"\n        value={message}\n        onChange={(e) => setMessage(e.target.value)}\n        placeholder={placeholder}\n        maxLength={maxLength}\n        disabled={disabled || !isConnected}\n        className=\"flex-1 px-3 py-2 rounded border\"\n      />\n      <button\n        type=\"submit\"\n        disabled={disabled || !message.trim() || !isConnected}\n        className=\"px-4 py-2 rounded disabled:opacity-50\"\n      >\n        Send\n      </button>\n    </form>\n  );\n};","import * as React from 'react';\nimport { useEffect } from 'react';\nimport { MessagesProps } from './types';\nimport { useChat } from '../../context/ChatContext';\nimport { clsx } from \"clsx\";\nimport { PartialMessageRequestDto } from \"../../types\";\n\nexport const Messages: React.FC<MessagesProps> = ({\n                                                    className = '',\n                                                    containerClassName = '',\n                                                    messageClassName = '',\n                                                    renderMessage\n                                                  }) => {\n  const {\n    messages: { data: messages, refetch }, currentUser: {\n      id: currentUserId\n    },\n  } = useChat();\n  const messagesEndRef = React.useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    refetch()\n  }, []);\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n\n  React.useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n\n  const defaultRenderMessage = (message: PartialMessageRequestDto) => {\n    return (\n      <div\n        key={message.participant_id.toString() + message.content}\n        className={clsx(\n          messageClassName,\n          'flex flex-col max-w-[70%]',\n          message.participant_id === currentUserId\n            ? 'ml-auto items-end'\n            : 'items-start'\n        )}\n      >\n      <span className=\"text-xs text-muted-foreground\">\n        {message.participant_id === currentUserId\n          ? ''\n          : message.participant_id ?? 'Some user'}\n      </span>\n        <div\n          className={clsx(\n            'rounded-lg px-1 max-w-[90%]',\n            message.participant_id === currentUserId\n              ? 'bg-blue-500 text-white self-end'\n              : 'bg-neutral-200 text-neutral-800 self-start'\n          )}\n        >\n          <p>{message.content}</p>\n        </div>\n      </div>)\n  };\n\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      <div className={`flex-1 overflow-y-auto p-4 space-y-4 ${containerClassName}`}>\n        {messages?.map((message, index) => (\n          <div key={index} className=\"max-w-[70%]\">\n            {renderMessage ? renderMessage(message) : defaultRenderMessage(message)}\n          </div>\n        ))}\n        <div ref={messagesEndRef}/>\n      </div>\n    </div>\n  );\n};","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;"]}
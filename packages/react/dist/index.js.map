{"version":3,"sources":["/Users/christos/dev/next-chat-project/packages/react/dist/index.js","../src/index.ts","../src/context/ChatContext/index.tsx","../src/context/ChatContext/useChannels.ts","../src/lib/logError.ts","../src/config.ts","../src/lib/apiRequest.ts","../src/services/index.ts","../src/context/ChatContext/useWebsocket.ts","../src/context/ChatContext/useChannelMessage.ts","../src/components/ChannelList/index.tsx","../src/components/MessageInput/index.tsx","../src/components/Messages/index.tsx","../../../node_modules/clsx/dist/clsx.mjs"],"names":["__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__export","target","all","name","get","enumerable","__copyProps","to","from","except","desc","key","call","__toESM","mod","isNodeMode","__esModule","value","__toCommonJS","index_exports","ChannelList","ChatProvider","MessageInput","Messages","useChat","module","exports","React","require","import_react","logError","error","additionalContext","message","stack","Error","String","errorLog","timestamp","Date","toISOString","console","config","rust_api_url","rust_ws_url","apiRequest","path","fetchOptions","serverOptions","defaultHeaders","serverUrl","url","response","contentType","errorData","fetch","headers","ok","includes","JSON","status","stringify","body","json","logErrorMetadata","context","fetchChannels","method","Accept","postMessage","fetchMessagesByChannelId","channelId","useChannels","channelName","data","useState","setData","isLoading","setIsLoading","setError","fetchData","err","useEffect","currentChannelId","find","channel","id","channels","isChannelsLoading","channelsError","refetchChannels","useWebSocket","import_react2","isConnected","setIsConnected","messages","setMessages","ws","useRef","connect","log","current","readyState","WebSocket","onopen","onmessage","event","parse","prev","participant_id","channel_name","content","onclose","OPEN","close","useChannelMessages","import_react3","fetchMessages","useCallback","areMessagesLoading","messagesError","refetchMessages","ChatContext","createContext","children","organizationToken","userId","userName","options","reconnectInterval","maxReconnectAttempts","debug","wsMessages","channelMessages","import_react4","useMemo","currentUser","activeChannel","refetch","wsEndpoint","createElement","Provider","useContext","limit","onChatSelect","customStyles","renderItem","React2","className","container","map","onClick","chatItem","placeholder","onSend","maxLength","disabled","React3","setMessage","currentUserId","handleSubmit","e","preventDefault","trim","send","onSubmit","type","onChange","r","t","f","n","Array","isArray","o","length","clsx","arguments","containerClassName","messageClassName","renderMessage","messagesEndRef","React4","import_react5","scrollToBottom","scrollIntoView","behavior","defaultRenderMessage","toString","index","ref"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  ChannelList: () => ChannelList,\n  ChatProvider: () => ChatProvider,\n  MessageInput: () => MessageInput,\n  Messages: () => Messages,\n  useChat: () => useChat\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/context/ChatContext/index.tsx\nvar React = __toESM(require(\"react\"));\nvar import_react4 = require(\"react\");\n\n// src/context/ChatContext/useChannels.ts\nvar import_react = require(\"react\");\n\n// src/lib/logError.ts\nvar logError = (error, additionalContext = {}) => {\n  let message;\n  let stack;\n  if (error instanceof Error) {\n    message = error.message;\n    stack = error.stack;\n  } else {\n    message = String(error);\n    stack = void 0;\n  }\n  const errorLog = {\n    message,\n    stack,\n    timestamp: (/* @__PURE__ */ new Date()).toISOString(),\n    ...additionalContext\n  };\n  console.error(errorLog);\n};\n\n// src/config.ts\nvar config = {\n  rust_api_url: \"https://api.rechat.cloud\",\n  rust_ws_url: \"wss://api.rechat.cloud/ws\"\n};\n\n// src/lib/apiRequest.ts\nasync function apiRequest(path, fetchOptions = {}, serverOptions = {}) {\n  const defaultHeaders = {\n    \"Content-Type\": \"application/json\"\n  };\n  const { serverUrl = config.rust_api_url } = serverOptions;\n  const url = `${serverUrl}${path}`;\n  try {\n    const response = await fetch(url, {\n      ...fetchOptions,\n      headers: {\n        ...defaultHeaders,\n        ...fetchOptions.headers\n      }\n    });\n    const contentType = response.headers.get(\"content-type\");\n    if (!response.ok) {\n      if (!contentType || !contentType.includes(\"application/json\")) {\n        throw new Error(\n          `${url} <- Error ${response.status}: Invalid content-type. Expected application/json, got ${JSON.stringify(response.body)}`\n        );\n      }\n      const errorData = await response.json();\n      throw new Error(\n        `${url} <- Error ${response.status}: ${JSON.stringify(\n          errorData,\n          null,\n          2\n        )} `\n      );\n    }\n    if (response.status === 204) {\n      return { status: \"204\" };\n    }\n    return await response.json();\n  } catch (error) {\n    if (error instanceof Error) {\n      logErrorMetadata(error, url);\n    } else {\n      logError(error, { context: \"Unexpected Error\", url });\n    }\n    throw error;\n  }\n}\nvar logErrorMetadata = (error, url) => {\n  if (error.name === \"AbortError\") {\n    logError(`Timeout \\u2013 ${error.name} ${error}`, {\n      context: \"Timeout Error\",\n      url\n    });\n  } else {\n    logError(`${error.name} ${error}`, { context: \"Fetch Error\", url });\n  }\n};\n\n// src/services/index.ts\nvar fetchChannels = async () => {\n  return await apiRequest(\n    \"/api/channels\",\n    {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      }\n    }\n  );\n};\nvar postMessage = async (message) => {\n  return await apiRequest(\n    \"/api/messages\",\n    {\n      method: \"POST\",\n      body: JSON.stringify(message)\n    }\n  );\n};\nvar fetchMessagesByChannelId = async ({ channelId }) => {\n  return await apiRequest(\n    `/api/messages/${channelId}`,\n    {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      }\n    }\n  );\n};\n\n// src/context/ChatContext/useChannels.ts\nvar useChannels = ({ channelName }) => {\n  const [data, setData] = (0, import_react.useState)();\n  const [isLoading, setIsLoading] = (0, import_react.useState)(false);\n  const [error, setError] = (0, import_react.useState)(null);\n  const fetchData = async () => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const { data: data2 } = await fetchChannels();\n      setData(data2);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error(\"Failed to fetch channels\"));\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  (0, import_react.useEffect)(() => {\n    fetchData();\n  }, []);\n  return {\n    currentChannelId: data?.find((channel) => channelName === channel.name)?.id,\n    channels: data,\n    isChannelsLoading: isLoading,\n    channelsError: error,\n    refetchChannels: fetchData\n  };\n};\n\n// src/context/ChatContext/useWebsocket.ts\nvar import_react2 = require(\"react\");\nfunction useWebSocket(channelName) {\n  const [isConnected, setIsConnected] = (0, import_react2.useState)(false);\n  const [messages, setMessages] = (0, import_react2.useState)([]);\n  const ws = (0, import_react2.useRef)(null);\n  (0, import_react2.useEffect)(() => {\n    const connect = () => {\n      console.log(ws.current, ws.current?.readyState);\n      console.log(\"Connecting to WebSocket the \", channelName);\n      ws.current = new WebSocket(`${config.rust_ws_url}/chat/${channelName}`);\n      ws.current.onopen = () => {\n        setIsConnected(true);\n        console.log(\"WebSocket connected\");\n      };\n      ws.current.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        setMessages((prev) => [...prev, {\n          participant_id: data.participant_id,\n          channel_name: data.channel_name,\n          content: data.content\n        }]);\n      };\n      ws.current.onclose = () => {\n        setIsConnected(false);\n        console.log(\"WebSocket closed\");\n      };\n    };\n    connect();\n    return () => {\n      if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n        ws.current.close();\n      }\n    };\n  }, [channelName]);\n  return { isConnected, messages, ws: ws.current };\n}\n\n// src/context/ChatContext/useChannelMessage.ts\nvar import_react3 = require(\"react\");\nfunction useChannelMessages(channelId) {\n  const [messages, setMessages] = (0, import_react3.useState)([]);\n  const [isLoading, setIsLoading] = (0, import_react3.useState)(false);\n  const [error, setError] = (0, import_react3.useState)(null);\n  const fetchMessages = (0, import_react3.useCallback)(async () => {\n    if (!channelId) return;\n    setIsLoading(true);\n    try {\n      const { data } = await fetchMessagesByChannelId({ channelId });\n      setMessages(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error(\"Failed to fetch messages\"));\n    } finally {\n      setIsLoading(false);\n    }\n  }, [channelId]);\n  (0, import_react3.useEffect)(() => {\n    fetchMessages();\n  }, [channelId, fetchMessages]);\n  return { messages, areMessagesLoading: isLoading, messagesError: error, refetchMessages: fetchMessages };\n}\n\n// src/context/ChatContext/index.tsx\nvar ChatContext = React.createContext(null);\nvar ChatProvider = ({\n  children,\n  organizationToken,\n  channelName,\n  userId,\n  userName = \"Unknown user\",\n  options = {\n    reconnectInterval: 3e3,\n    maxReconnectAttempts: 5,\n    debug: false\n  }\n}) => {\n  const { isConnected, messages: wsMessages, ws } = useWebSocket(channelName);\n  const {\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels,\n    currentChannelId\n  } = useChannels({ channelName });\n  const {\n    messages: channelMessages,\n    areMessagesLoading,\n    refetchMessages,\n    messagesError\n  } = useChannelMessages(currentChannelId);\n  const value = (0, import_react4.useMemo)(() => ({\n    organizationToken,\n    currentUser: {\n      id: userId,\n      userName,\n      isConnected\n    },\n    activeChannel: {\n      name: channelName,\n      id: currentChannelId\n    },\n    channels: {\n      data: channels,\n      isLoading: isChannelsLoading,\n      error: channelsError,\n      refetch: refetchChannels\n    },\n    messages: {\n      data: [...channelMessages || [], ...wsMessages || []],\n      isLoading: areMessagesLoading,\n      error: messagesError,\n      refetch: refetchMessages\n    },\n    wsEndpoint: `${config.rust_ws_url}/chat/${channelName}`,\n    ws\n  }), [\n    organizationToken,\n    channelName,\n    currentChannelId,\n    isConnected,\n    channelMessages,\n    wsMessages,\n    areMessagesLoading,\n    messagesError,\n    refetchMessages,\n    ws,\n    userId,\n    userName,\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels\n  ]);\n  return /* @__PURE__ */ React.createElement(ChatContext.Provider, { value }, children);\n};\nvar useChat = () => {\n  const context = React.useContext(ChatContext);\n  if (!context) {\n    throw new Error(\"useChat must be used within a ChatProvider\");\n  }\n  return context;\n};\n\n// src/components/ChannelList/index.tsx\nvar React2 = __toESM(require(\"react\"));\nvar ChannelList = ({\n  limit = 50,\n  onChatSelect,\n  customStyles = {},\n  renderItem\n}) => {\n  const { channels } = useChat();\n  if (channels.isLoading) {\n    return /* @__PURE__ */ React2.createElement(\"div\", null, \"Loading chats...\");\n  }\n  return /* @__PURE__ */ React2.createElement(\"div\", { className: customStyles.container }, channels.data?.map((channel) => /* @__PURE__ */ React2.createElement(\n    \"div\",\n    {\n      key: channel.id,\n      onClick: () => onChatSelect?.(channel),\n      className: customStyles.chatItem\n    },\n    renderItem ? renderItem(channel) : /* @__PURE__ */ React2.createElement(\"div\", null, /* @__PURE__ */ React2.createElement(\"h3\", null, channel.name))\n  )));\n};\n\n// src/components/MessageInput/index.tsx\nvar React3 = __toESM(require(\"react\"));\nvar MessageInput = ({\n  placeholder = \"Type a message...\",\n  onSend,\n  maxLength = 1e3,\n  disabled = false\n}) => {\n  const [message, setMessage] = React3.useState(\"\");\n  const {\n    ws,\n    currentUser: {\n      id: currentUserId,\n      isConnected\n    },\n    activeChannel: {\n      name: channelName\n    }\n  } = useChat();\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    if (message.trim() && ws && isConnected) {\n      const data = {\n        channel_name: channelName,\n        participant_id: currentUserId,\n        content: message\n      };\n      ws.send(JSON.stringify(data));\n      onSend?.(message);\n      setMessage(\"\");\n      try {\n        await postMessage(data);\n      } catch (e2) {\n        console.error(e2);\n      }\n    }\n  };\n  return /* @__PURE__ */ React3.createElement(\"form\", { onSubmit: handleSubmit, className: \"flex gap-2\" }, /* @__PURE__ */ React3.createElement(\n    \"input\",\n    {\n      type: \"text\",\n      value: message,\n      onChange: (e) => setMessage(e.target.value),\n      placeholder,\n      maxLength,\n      disabled: disabled || !isConnected,\n      className: \"flex-1 px-3 py-2 rounded border\"\n    }\n  ), /* @__PURE__ */ React3.createElement(\n    \"button\",\n    {\n      type: \"submit\",\n      disabled: disabled || !message.trim() || !isConnected,\n      className: \"px-4 py-2 rounded disabled:opacity-50\"\n    },\n    \"Send\"\n  ));\n};\n\n// src/components/Messages/index.tsx\nvar React4 = __toESM(require(\"react\"));\nvar import_react5 = require(\"react\");\n\n// ../../node_modules/clsx/dist/clsx.mjs\nfunction r(e) {\n  var t, f, n = \"\";\n  if (\"string\" == typeof e || \"number\" == typeof e) n += e;\n  else if (\"object\" == typeof e) if (Array.isArray(e)) {\n    var o = e.length;\n    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n  } else for (f in e) e[f] && (n && (n += \" \"), n += f);\n  return n;\n}\nfunction clsx() {\n  for (var e, t, f = 0, n = \"\", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += \" \"), n += t);\n  return n;\n}\n\n// src/components/Messages/index.tsx\nvar Messages = ({\n  className = \"\",\n  containerClassName = \"\",\n  messageClassName = \"\",\n  renderMessage\n}) => {\n  const {\n    messages: { data: messages, refetch },\n    currentUser: {\n      id: currentUserId\n    }\n  } = useChat();\n  const messagesEndRef = React4.useRef(null);\n  (0, import_react5.useEffect)(() => {\n    refetch();\n  }, []);\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n  React4.useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n  const defaultRenderMessage = (message) => {\n    return /* @__PURE__ */ React4.createElement(\n      \"div\",\n      {\n        key: message.participant_id.toString() + message.content,\n        className: clsx(\n          messageClassName,\n          \"flex flex-col max-w-[70%]\",\n          message.participant_id === currentUserId ? \"ml-auto items-end\" : \"items-start\"\n        )\n      },\n      /* @__PURE__ */ React4.createElement(\"span\", { className: \"text-xs text-muted-foreground\" }, message.participant_id === currentUserId ? \"\" : message.participant_id ?? \"Some user\"),\n      /* @__PURE__ */ React4.createElement(\n        \"div\",\n        {\n          className: clsx(\n            \"rounded-lg px-1 max-w-[90%]\",\n            message.participant_id === currentUserId ? \"bg-blue-500 text-white self-end\" : \"bg-neutral-200 text-neutral-800 self-start\"\n          )\n        },\n        /* @__PURE__ */ React4.createElement(\"p\", null, message.content)\n      )\n    );\n  };\n  return /* @__PURE__ */ React4.createElement(\"div\", { className: `flex flex-col h-full ${className}` }, /* @__PURE__ */ React4.createElement(\"div\", { className: `flex-1 overflow-y-auto p-4 space-y-4 ${containerClassName}` }, messages?.map((message, index) => /* @__PURE__ */ React4.createElement(\"div\", { key: index, className: \"max-w-[70%]\" }, renderMessage ? renderMessage(message) : defaultRenderMessage(message))), /* @__PURE__ */ React4.createElement(\"div\", { ref: messagesEndRef })));\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  ChannelList,\n  ChatProvider,\n  MessageInput,\n  Messages,\n  useChat\n});\n","export { ChatProvider } from './context/ChatContext';\nexport { ChannelList } from './components/ChannelList';\nexport { MessageInput } from './components/MessageInput';\nexport { Messages } from './components/Messages';\n\nexport { useChat } from './context/ChatContext';\n\nexport type { ChatListProps } from './components/ChannelList/types';\nexport type { MessageInputProps } from './components/MessageInput/types';\nexport type { MessagesProps } from './components/Messages/types';\n\nexport type { ChannelResponseDto, ChannelsResponseDto, MessageResponseDto, MessagesResponseDto } from './types';","import * as React from 'react';\nimport { useMemo } from 'react';\nimport { useChannels } from \"./useChannels\";\nimport { useWebSocket } from \"./useWebsocket\";\nimport { useChannelMessages } from \"./useChannelMessage\";\nimport { config } from \"../../config\";\nimport { ChannelsResponseDto, MessageRequestDto, MessageResponseDto, CombinedMessagesDto } from \"../../types\";\n\ninterface Resource<T> {\n  data: T | undefined;\n  isLoading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n}\n\ninterface ChatContextType {\n  organizationToken: string;\n  activeChannel: {\n    name: string;\n    id: string | undefined;\n  }\n  currentUser: {\n    id: string;\n    userName: string;\n    isConnected: boolean;\n  }\n  wsEndpoint: string;\n  ws: WebSocket | null;\n  messages: Resource<CombinedMessagesDto>;\n  channels: Resource<ChannelsResponseDto>;\n}\n\ninterface ChatProviderProps {\n  children: React.ReactNode;\n  organizationToken: string;\n  channelName: string;\n  userId: string;\n  userName?: string;\n  options?: {\n    reconnectInterval?: number;\n    maxReconnectAttempts?: number;\n    debug?: boolean;\n  };\n}\n\n\nconst ChatContext = React.createContext<ChatContextType | null>(null);\n\nexport const ChatProvider: React.FC<ChatProviderProps> = ({\n                                                            children,\n                                                            organizationToken,\n                                                            channelName,\n                                                            userId,\n                                                            userName = 'Unknown user',\n                                                            options = {\n                                                              reconnectInterval: 3000,\n                                                              maxReconnectAttempts: 5,\n                                                              debug: false\n                                                            }\n                                                          }) => {\n  const { isConnected, messages: wsMessages, ws } = useWebSocket(channelName);\n  const {\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels,\n    currentChannelId\n  } = useChannels({ channelName });\n  const {\n    messages: channelMessages,\n    areMessagesLoading,\n    refetchMessages,\n    messagesError\n  } = useChannelMessages(currentChannelId);\n\n  const value = useMemo<ChatContextType>(() => ({\n    organizationToken,\n    currentUser: {\n      id: userId,\n      userName: userName,\n      isConnected,\n\n    },\n    activeChannel: {\n      name: channelName,\n      id: currentChannelId\n    },\n    channels: {\n      data: channels,\n      isLoading: isChannelsLoading,\n      error: channelsError,\n      refetch: refetchChannels\n    },\n    messages: {\n      data: [...(channelMessages || []), ...(wsMessages || [])],\n      isLoading: areMessagesLoading,\n      error: messagesError,\n      refetch: refetchMessages\n    },\n    wsEndpoint: `${config.rust_ws_url}/chat/${channelName}`,\n    ws,\n  }), [\n    organizationToken,\n    channelName,\n    currentChannelId,\n    isConnected,\n    channelMessages,\n    wsMessages,\n    areMessagesLoading,\n    messagesError,\n    refetchMessages,\n    ws,\n    userId,\n    userName,\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels\n  ]);\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};\n\nexport const useChat = () => {\n  const context = React.useContext(ChatContext);\n  if (!context) {\n    throw new Error('useChat must be used within a ChatProvider');\n  }\n  return context;\n};","import { useEffect, useState } from 'react';\nimport { fetchChannels } from \"../../services\";\nimport { ChannelsResponseDto } from \"../../types\";\n\ninterface UseChannelsReturn {\n  channels: ChannelsResponseDto | undefined;\n  currentChannelId: string | undefined;\n  isChannelsLoading: boolean;\n  channelsError: Error | null;\n  refetchChannels: () => Promise<void>;\n}\n\nexport const useChannels = ({ channelName }: { channelName: string }): UseChannelsReturn => {\n  const [data, setData] = useState<ChannelsResponseDto>();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchData = async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { data } = await fetchChannels();\n      setData(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch channels'));\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return {\n    currentChannelId: data?.find(channel => channelName === channel.name)?.id,\n    channels: data,\n    isChannelsLoading: isLoading,\n    channelsError: error,\n    refetchChannels: fetchData\n  };\n};","interface ErrorLog {\n  message: string;\n  stack?: string;\n  timestamp: string;\n\n  [key: string]: any; // Additional dynamic properties\n}\n\nexport const logError = (\n  error: unknown,\n  additionalContext: Record<string, unknown> = {}\n): void => {\n  // Determine the error message and stack based on the error type\n  let message: string;\n  let stack: string | undefined;\n\n  if (error instanceof Error) {\n    message = error.message;\n    stack = error.stack;\n  } else {\n    message = String(error); // Convert error to string if it's not an instance of Error\n    stack = undefined;\n  }\n\n  const errorLog: ErrorLog = {\n    message,\n    stack,\n    timestamp: new Date().toISOString(),\n    ...additionalContext\n  };\n\n  // Sentry.captureException(error, {\n  //   extra: errorLog\n  // });\n\n  console.error(errorLog);\n};\n","export const config = {\n  rust_api_url: 'https://api.rechat.cloud',\n  rust_ws_url: 'wss://api.rechat.cloud/ws',\n};","import { logError } from './logError';\nimport { config } from \"../config\";\n\nexport async function apiRequest<T>(\n  path: string,\n  fetchOptions: RequestInit = {},\n  serverOptions: { serverUrl?: string; cache?: boolean } = {}\n): Promise<T> {\n  const defaultHeaders = {\n    'Content-Type': 'application/json',\n  };\n\n  const { serverUrl = config.rust_api_url, } = serverOptions;\n  const url = `${serverUrl}${path}`;\n\n  try {\n\n    const response = await fetch(url, {\n      ...fetchOptions,\n      headers: {\n        ...defaultHeaders,\n        ...fetchOptions.headers,\n      },\n    });\n\n    const contentType = response.headers.get('content-type');\n\n    if (!response.ok) {\n      // if the response is not ok, and is not a json but and html, eg 502 errors\n      if (!contentType || !contentType.includes('application/json')) {\n        throw new Error(\n          `${url} <- Error ${response.status}: Invalid content-type. Expected application/json, got ${JSON.stringify(response.body)}`\n        );\n      }\n\n      const errorData = await response.json();\n\n\n      throw new Error(\n        `${url} <- Error ${response.status}: ${JSON.stringify(\n          errorData,\n          null,\n          2\n        )} `\n      );\n    }\n\n    if (response.status === 204) {\n      return { status: '204' } as T;\n    }\n\n    return (await response.json()) as T;\n  } catch (error) {\n    if (error instanceof Error) {\n      logErrorMetadata(error, url);\n    } else {\n      logError(error, { context: 'Unexpected Error', url });\n    }\n    throw error;\n  }\n}\n\nconst logErrorMetadata = (error: Error, url: string) => {\n  if (error.name === 'AbortError') {\n    logError(`Timeout â€“ ${error.name} ${error}`, {\n      context: 'Timeout Error',\n      url\n    });\n  } else {\n    logError(`${error.name} ${error}`, { context: 'Fetch Error', url });\n  }\n};\n","import { apiRequest } from \"../lib/apiRequest\";\nimport { ChannelsResponseDto, MessageRequestDto, MessageResponseDto, MessagesResponseDto } from \"../types\";\n\n\nexport const fetchChannels = async () => {\n  return await apiRequest<{ data: ChannelsResponseDto, message: string }>(\n    '/api/channels',\n    {\n      method: \"GET\",\n      headers: {\n        Accept: 'application/json',\n      }\n    }\n  );\n}\n\nexport const createNewChannel = async ({ name }: { name: string }) => {\n  return await apiRequest<{ data: ChannelsResponseDto, message: string }>(\n    '/api/channels',\n    {\n      method: \"POST\",\n      headers: {\n        Accept: 'application/json',\n      },\n      body: JSON.stringify({ name })\n    },\n  );\n}\n\nexport const postMessage = async (message: MessageRequestDto) => {\n  return await apiRequest<{ data: MessageResponseDto, message: string }>(\n    '/api/messages',\n    {\n      method: \"POST\",\n      body: JSON.stringify(message)\n    },\n  );\n}\n\nexport const fetchMessagesByChannelId = async ({ channelId }: { channelId: string }) => {\n  return await apiRequest<{ data: MessagesResponseDto, message: string }>(\n    `/api/messages/${channelId}`,\n    {\n      method: \"GET\",\n      headers: {\n        Accept: 'application/json',\n      },\n    },\n  );\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { config } from \"../../config\";\nimport { MessageRequestDto } from \"../../types\";\n\nexport function useWebSocket(channelName: string) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState<MessageRequestDto[]>([]);\n  const ws = useRef<WebSocket | null>(null);\n\n\n  useEffect(() => {\n    const connect = () => {\n      // Only create a new connection if there isn't one already\n      console.log(ws.current, ws.current?.readyState)\n      console.log('Connecting to WebSocket the ', channelName);\n      ws.current = new WebSocket(`${config.rust_ws_url}/chat/${channelName}`);\n\n      ws.current.onopen = () => {\n        setIsConnected(true);\n        console.log('WebSocket connected');\n      };\n\n      ws.current.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        setMessages(prev => [...prev, {\n          participant_id: data.participant_id,\n          channel_name: data.channel_name,\n          content: data.content,\n        }]);\n      };\n\n      ws.current.onclose = () => {\n        setIsConnected(false);\n        console.log('WebSocket closed');\n      };\n    };\n\n    connect();\n\n    // Cleanup function\n    return () => {\n      // Only close if connection exists and is open\n      if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n        ws.current.close();\n      }\n    };\n  }, [channelName]);\n\n  return { isConnected, messages, ws: ws.current };\n}","import { useCallback, useEffect, useState } from 'react';\n\nimport { MessagesResponseDto } from \"../../types\";\nimport { fetchMessagesByChannelId } from \"../../services\";\n\nexport function useChannelMessages(channelId?: string) {\n  const [messages, setMessages] = useState<MessagesResponseDto>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchMessages = useCallback(async () => {\n    if (!channelId) return;\n\n    setIsLoading(true);\n    try {\n      const { data } = await fetchMessagesByChannelId({ channelId });\n      setMessages(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch messages'));\n    } finally {\n      setIsLoading(false);\n    }\n  }, [channelId]);\n\n  useEffect(() => {\n    fetchMessages();\n  }, [channelId, fetchMessages]);\n\n  return { messages, areMessagesLoading: isLoading, messagesError: error, refetchMessages: fetchMessages };\n}","'use client'\nimport * as React from 'react';\nimport { ChatListProps } from './types';\nimport { useChat } from \"../../context/ChatContext\";\n\nexport const ChannelList: React.FC<ChatListProps> = ({\n                                                    limit = 50,\n                                                    onChatSelect,\n                                                    customStyles = {},\n                                                    renderItem\n                                                  }) => {\n  const { channels } = useChat();\n\n  if (channels.isLoading) {\n    return <div>Loading chats...</div>;\n  }\n\n  return (\n    <div className={customStyles.container}>\n      {channels.data?.map((channel) => (\n        <div\n          key={channel.id}\n          onClick={() => onChatSelect?.(channel)}\n          className={customStyles.chatItem}\n        >\n          {renderItem ? (\n            renderItem(channel)\n          ) : (\n            <div>\n              <h3>{channel.name}</h3>\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n};","import * as React from 'react';\nimport { MessageInputProps } from './types';\nimport { useChat } from '../../context/ChatContext';\nimport { postMessage } from \"../../services\";\nimport { MessageRequestDto } from \"../../types\";\n\nexport const MessageInput: React.FC<MessageInputProps> = ({\n                                                            placeholder = 'Type a message...',\n                                                            onSend,\n                                                            maxLength = 1000,\n                                                            disabled = false,\n\n                                                          }) => {\n  const [message, setMessage] = React.useState('');\n  const {\n    ws,\n    currentUser: {\n      id: currentUserId,\n      isConnected\n    },\n    activeChannel: {\n      name: channelName\n    },\n  } = useChat();\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (message.trim() && ws && isConnected) {\n      const data = {\n        channel_name: channelName,\n        participant_id: currentUserId,\n        content: message,\n      } as MessageRequestDto\n\n      ws.send(JSON.stringify(data));\n\n      onSend?.(message);\n      setMessage('');\n\n      try {\n        await postMessage(data);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"flex gap-2\">\n      <input\n        type=\"text\"\n        value={message}\n        onChange={(e) => setMessage(e.target.value)}\n        placeholder={placeholder}\n        maxLength={maxLength}\n        disabled={disabled || !isConnected}\n        className=\"flex-1 px-3 py-2 rounded border\"\n      />\n      <button\n        type=\"submit\"\n        disabled={disabled || !message.trim() || !isConnected}\n        className=\"px-4 py-2 rounded disabled:opacity-50\"\n      >\n        Send\n      </button>\n    </form>\n  );\n};","import * as React from 'react';\nimport { useEffect } from 'react';\nimport { MessagesProps } from './types';\nimport { useChat } from '../../context/ChatContext';\nimport { clsx } from \"clsx\";\nimport { PartialMessageRequestDto } from \"../../types\";\n\nexport const Messages: React.FC<MessagesProps> = ({\n                                                    className = '',\n                                                    containerClassName = '',\n                                                    messageClassName = '',\n                                                    renderMessage\n                                                  }) => {\n  const {\n    messages: { data: messages, refetch }, currentUser: {\n      id: currentUserId\n    },\n  } = useChat();\n  const messagesEndRef = React.useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    refetch()\n  }, []);\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n\n  React.useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n\n  const defaultRenderMessage = (message: PartialMessageRequestDto) => {\n    return (\n      <div\n        key={message.participant_id.toString() + message.content}\n        className={clsx(\n          messageClassName,\n          'flex flex-col max-w-[70%]',\n          message.participant_id === currentUserId\n            ? 'ml-auto items-end'\n            : 'items-start'\n        )}\n      >\n      <span className=\"text-xs text-muted-foreground\">\n        {message.participant_id === currentUserId\n          ? ''\n          : message.participant_id ?? 'Some user'}\n      </span>\n        <div\n          className={clsx(\n            'rounded-lg px-1 max-w-[90%]',\n            message.participant_id === currentUserId\n              ? 'bg-blue-500 text-white self-end'\n              : 'bg-neutral-200 text-neutral-800 self-start'\n          )}\n        >\n          <p>{message.content}</p>\n        </div>\n      </div>)\n  };\n\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      <div className={`flex-1 overflow-y-auto p-4 space-y-4 ${containerClassName}`}>\n        {messages?.map((message, index) => (\n          <div key={index} className=\"max-w-[70%]\">\n            {renderMessage ? renderMessage(message) : defaultRenderMessage(message)}\n          </div>\n        ))}\n        <div ref={messagesEndRef}/>\n      </div>\n    </div>\n  );\n};","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;"]}